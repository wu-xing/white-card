!function(n){function t(i){if(e[i])return e[i].exports;var o=e[i]={exports:{},id:i,loaded:!1};return n[i].call(o.exports,o,o.exports,t),o.loaded=!0,o.exports}var e={};return t.m=n,t.c=e,t.p="/static/js/",t(0)}([function(n,t,e){"use strict";e(1),e(2)},function(n,t,e){"use strict";e(5),FontFaceOnload("YueSong",{success:function(){setTimeout(function(){window.document.body.className+="yue-song-font"})}})},function(n,t){"use strict";var e=window.innerWidth,i=!1,o=function(){i=768>e};window.addEventListener("resize",function(){e=window.innerWidth,o()});var s=function(){function n(){l.forEach(function(n){n.style.display="block"})}function t(){l.forEach(function(n){n.style.display="none"})}function e(){l.forEach(function(n,t){n.classList.remove("active"),n.style.transform=""}),y=!1}var o=window.innerWidth/2,s=function(){o=window.innerWidth/2},a=document.querySelector(".slide-tag");window.addEventListener("resize",s),i&&a.classList.add("hide");var r,c=!0,f=function(n){if(i){var e=n.changedTouches[0].clientX;a.classList.remove("hide"),o>e?(a.classList.remove("right"),a.classList.add("left"),c||t(),c=!0):(a.classList.remove("left"),a.classList.add("right"),c&&t(),c=!1),r&&(clearTimeout(r),r=null),r=setTimeout(function(){a.classList.add("hide")},2e3)}};window.document.body.addEventListener("touchstart",f);var l=a.querySelectorAll("ul li");l=Array.prototype.slice.apply(l);var d=l.length,h=90/(d-1),u=Math.PI/180,p=7,m=a.querySelector(".toggle-button"),y=!1;m.addEventListener("click",function(t){if(i){if(y)return e();n(),y=!0,l.forEach(function(n,t){var e=t*h*u,i=(p*Math.cos(e)*(c?1:-1)).toFixed(6),o=(-p*Math.sin(e)).toFixed(6),s="translate3d("+i+"rem, "+o+"rem, 0)";n.classList.add("active"),setTimeout(function(){n.style.transform=s})})}}),window.document.body.addEventListener("touchstart",function(n){i&&(Array.from(n.target.classList).indexOf("slide-button")>=0||Array.from(n.target.parentElement.classList).indexOf("slide-button")>=0||y&&e())})};s()},function(n,t){n.exports="/*! fontfaceonload - v0.1.7 - 2015-10-26\n * https://github.com/zachleat/fontfaceonload\n * Copyright (c) 2015 Zach Leatherman (@zachleat)\n * MIT License */\n\n;(function( win, doc ) {\n	\"use strict\";\n\n	var TEST_STRING = 'AxmTYklsjo190QW',\n		SANS_SERIF_FONTS = 'sans-serif',\n		SERIF_FONTS = 'serif',\n\n		defaultOptions = {\n			tolerance: 2, // px\n			delay: 100,\n			glyphs: '',\n			success: function() {},\n			error: function() {},\n			timeout: 5000,\n			weight: '400', // normal\n			style: 'normal'\n		},\n\n		// See https://github.com/typekit/webfontloader/blob/master/src/core/fontruler.js#L41\n		style = [\n			'display:block',\n			'position:absolute',\n			'top:-999px',\n			'left:-999px',\n			'font-size:48px',\n			'width:auto',\n			'height:auto',\n			'line-height:normal',\n			'margin:0',\n			'padding:0',\n			'font-variant:normal',\n			'white-space:nowrap'\n		],\n		html = '<div style=\"%s\">' + TEST_STRING + '</div>';\n\n	var FontFaceOnloadInstance = function() {\n		this.fontFamily = '';\n		this.appended = false;\n		this.serif = undefined;\n		this.sansSerif = undefined;\n		this.parent = undefined;\n		this.options = {};\n	};\n\n	FontFaceOnloadInstance.prototype.getMeasurements = function () {\n		return {\n			sansSerif: {\n				width: this.sansSerif.offsetWidth,\n				height: this.sansSerif.offsetHeight\n			},\n			serif: {\n				width: this.serif.offsetWidth,\n				height: this.serif.offsetHeight\n			}\n		};\n	};\n\n	FontFaceOnloadInstance.prototype.load = function () {\n		var startTime = new Date(),\n			that = this,\n			serif = that.serif,\n			sansSerif = that.sansSerif,\n			parent = that.parent,\n			appended = that.appended,\n			dimensions,\n			options = that.options,\n			ref = options.reference;\n\n		function getStyle( family ) {\n			return style\n				.concat( [ 'font-weight:' + options.weight, 'font-style:' + options.style ] )\n				.concat( \"font-family:\" + family )\n				.join( \";\" );\n		}\n\n		var sansSerifHtml = html.replace( /\\%s/, getStyle( SANS_SERIF_FONTS ) ),\n			serifHtml = html.replace( /\\%s/, getStyle(  SERIF_FONTS ) );\n\n		if( !parent ) {\n			parent = that.parent = doc.createElement( \"div\" );\n		}\n\n		parent.innerHTML = sansSerifHtml + serifHtml;\n		sansSerif = that.sansSerif = parent.firstChild;\n		serif = that.serif = sansSerif.nextSibling;\n\n		if( options.glyphs ) {\n			sansSerif.innerHTML += options.glyphs;\n			serif.innerHTML += options.glyphs;\n		}\n\n		function hasNewDimensions( dims, el, tolerance ) {\n			return Math.abs( dims.width - el.offsetWidth ) > tolerance ||\n					Math.abs( dims.height - el.offsetHeight ) > tolerance;\n		}\n\n		function isTimeout() {\n			return ( new Date() ).getTime() - startTime.getTime() > options.timeout;\n		}\n\n		(function checkDimensions() {\n			if( !ref ) {\n				ref = doc.body;\n			}\n			if( !appended && ref ) {\n				ref.appendChild( parent );\n				appended = that.appended = true;\n\n				dimensions = that.getMeasurements();\n\n				// Make sure we set the new font-family after we take our initial dimensions:\n				// handles the case where FontFaceOnload is called after the font has already\n				// loaded.\n				sansSerif.style.fontFamily = that.fontFamily + ', ' + SANS_SERIF_FONTS;\n				serif.style.fontFamily = that.fontFamily + ', ' + SERIF_FONTS;\n			}\n\n			if( appended && dimensions &&\n				( hasNewDimensions( dimensions.sansSerif, sansSerif, options.tolerance ) ||\n					hasNewDimensions( dimensions.serif, serif, options.tolerance ) ) ) {\n\n				options.success();\n			} else if( isTimeout() ) {\n				options.error();\n			} else {\n				if( !appended && \"requestAnimationFrame\" in window ) {\n					win.requestAnimationFrame( checkDimensions );\n				} else {\n					win.setTimeout( checkDimensions, options.delay );\n				}\n			}\n		})();\n	}; // end load()\n\n	FontFaceOnloadInstance.prototype.cleanFamilyName = function( family ) {\n		return family.replace( /[\\'\\\"]/g, '' ).toLowerCase();\n	};\n\n	FontFaceOnloadInstance.prototype.cleanWeight = function( weight ) {\n		// lighter and bolder not supported\n		var weightLookup = {\n			normal: '400',\n			bold: '700'\n		};\n\n		return '' + (weightLookup[ weight ] || weight);\n	};\n\n	FontFaceOnloadInstance.prototype.checkFontFaces = function( timeout ) {\n		var _t = this;\n		doc.fonts.forEach(function( font ) {\n			if( _t.cleanFamilyName( font.family ) === _t.cleanFamilyName( _t.fontFamily ) &&\n				_t.cleanWeight( font.weight ) === _t.cleanWeight( _t.options.weight ) &&\n				font.style === _t.options.style ) {\n				font.load().then(function() {\n					_t.options.success();\n					win.clearTimeout( timeout );\n				});\n			}\n		});\n	};\n\n	FontFaceOnloadInstance.prototype.init = function( fontFamily, options ) {\n		var timeout;\n\n		for( var j in defaultOptions ) {\n			if( !options.hasOwnProperty( j ) ) {\n				options[ j ] = defaultOptions[ j ];\n			}\n		}\n\n		this.options = options;\n		this.fontFamily = fontFamily;\n\n		// For some reason this was failing on afontgarde + icon fonts.\n		if( !options.glyphs && \"fonts\" in doc ) {\n			if( options.timeout ) {\n				timeout = win.setTimeout(function() {\n					options.error();\n				}, options.timeout );\n			}\n\n			this.checkFontFaces( timeout );\n		} else {\n			this.load();\n		}\n	};\n\n	var FontFaceOnload = function( fontFamily, options ) {\n		var instance = new FontFaceOnloadInstance();\n		instance.init(fontFamily, options);\n\n		return instance;\n	};\n\n	// intentional global\n	win.FontFaceOnload = FontFaceOnload;\n})( this, this.document );\n"},function(n,t){n.exports=function(n){"undefined"!=typeof execScript?execScript(n):eval.call(null,n)}},function(n,t,e){e(4)(e(3))}]);